-- creazione tabelle per il corso

drop table employee;

create table employee (
	id int generated by default as IDENTITY,
	id_contratto int,
	country varchar(50) not null,
	email varchar(50) not null,
	fullname varchar(50) not null,
	gender varchar(50) not null,
	address varchar(100),
	primary key (id),
	foreign key (id_contratto) references contratto(id_contratto)
)
delete from employee;

insert into employee (country, email, fullname, gender, address)
	values ('Italy', 'aa@bb.it', 'Marco Letruco', 'mascio', 'via bella luna 10 Milano'),
	 ('Italy', 'bb@vv.it', 'Andrea Depardie', 'mascio', 'Corso Agnelli 12 Torino'),	
	 ('Italy', 'cc@vv.it', 'Paolo Rosso', 'mascio', 'Corso Blue 12 Torino'),	
	 ('Italy', 'vvbb@vv.it', 'Cinzia Verde', 'femina', 'Via Lagrnage 355 Torino'),	
	 ('Italy', 'ssbb@vv.it', 'Gianni Leturco', 'mascio', 'Corso Francia Milano'),	
	 ('Italy', 'tt@vv.it', 'Alice Bianca', 'femina', 'Via suza 1 Torino'),	
	 ('Italy', 'uu@vv.it', 'Giuseppe Lagrande', 'mascio', 'Corso Monte 33 Roma')	
	
select * from employee e 	

drop table contratto;

create table contratto (
	id_contratto int generated by default as IDENTITY,
	id_categoria int,
	id_ruolo int,
	stipendio numeric(10) not null,
	data_assunzione date not null,
	data_dimissione date,
	primary key (id_contratto),
	foreign key (id_categoria) references categoria(id_categoria),
	foreign key (id_ruolo) references ruolo(id_ruolo)
)

delete from contratto;
insert into contratto (stipendio, data_assunzione)
	values (1500, '2025-05-01'),
	(1500, '2025-05-01'),
	(1600, '2025-05-01'),
	(1800, '2025-05-01'),
	(2000, '2025-05-01'),
	(2500, '2025-05-01')

	select * from contratto;
create table categoria (
	id_categoria int generated by default as IDENTITY,
	tipo varchar(100) not null,
	primary key (id_categoria)
)
	

insert into categoria (tipo)
	values ('Impiegato'),('Quadro'),('Dirigente')

select * from categoria;	


create table ruolo (
	id_ruolo int generated by default as IDENTITY,
	stipendio_minimo numeric(10) not null,
	descrizione varchar(100) not null,
	primary key (id_ruolo)
)

insert into ruolo (stipendio_minimo, descrizione)
	values (1000, 'amministrativo'),
		   (1200, 'tecnico'),
		   (1300, 'sviluppatore'),
		   (1800, 'capo progetto'),
		   (2000, 'commerciale')

select * from ruolo;


 -- Step 1 creazione view
CREATE or Replace view list_employee as
select e.fullname, e.gender , c.data_assunzione, c.stipendio, cat.tipo, r.descrizione
from employee e 
	left join contratto c 
			on c.id_contratto = e.id_contratto
	left join categoria cat
			on cat.id_categoria = c.id_categoria
	left join ruolo r 
			on r.id_ruolo = c.id_ruolo 

select * from list_employee l 

-- step 2 creazione funzione

create or replace function find_employees_simple(stipendio_min NUMERIC)
	returns table (
		id int,
		fullname varchar(50),
		data_assunzione DATE,
		stipendio NUMERIC,
		descrizione varchar(50),
		tipo varchar(100)
	) as $$
	begin
		return QUERY
		select 
			d.id,
			d.fullname,
			con.data_assunzione,
			con.stipendio,
			r.descrizione,
			cat.tipo
			from employee d
				left join contratto con 
					on d.id_contratto = con.id_contratto
				left join categoria cat
					on 	con.id_categoria = cat.id_categoria
				left join ruolo r
					on con.id_ruolo = r.id_ruolo
			where con.stipendio > stipendio_min;
	end;
	$$ language plpgsql;

	select * from find_employees_simple(1600);

-- stored procedure
	
create or replace procedure aumenta_stipendi_per_ruolo (
	p_min_stipendio numeric,
	p_ruolo varchar(100)
)
language plpgsql
as $$
begin
	update contratto
		set stipendio = stipendio * 1.10
		where stipendio > p_min_stipendio
		  and id_contratto in (
			select con.id_contratto
				from contratto con
				join ruolo r on con.id_ruolo = r.id_ruolo
					where lower(r.descrizione) = lower(p_ruolo) 		
			);
end;
$$;

-- esecuzione della stored procedura

call aumenta_stipendi_per_ruolo(1200, 'Sviluppatore Junior');


-- parametro interno alla stored procedura

create or replace procedure insert_new_categaria()
language plpgsql
as $$
declare
	v_new_cat varchar(100);
begin
	v_new_cat := 'Grande capo';
	
	insert into categoria (tipo) values (v_new_cat);
end;
$$;

call insert_new_categaria();

-- creazione nuova tabella

create table sp_employee (
	id_emp int generated by default as IDENTITY,
	annual_salary numeric not null,
	hourly_rate numeric generated always as (annual_salary /2080::numeric) stored null,
	primary key (id_emp)
)

insert into sp_employee (annual_salary) values (36000);

-- while dentro stored procedure
-- exit esce del loop
-- continue rimane nel loop pero sala il process...

create or replace procedure create_sp_employee(number_emp numeric)
	language plpgsql
	as $$
	declare
		startpay numeric := 36000;
		emp_num  int     := 1;
	begin
		number_emp := number_emp + 1;
		while(startpay < 2000000) loop

			if emp_num = number_emp then
				exit;
			end if;
			emp_num := emp_num + 1;

			if emp_num % 2 = 0 then
				continue;    
			end if;

			raise notice 'emp_id %', emp_num;
			
			insert into sp_employee(annual_salary) values (startpay);

			startpay := startpay + 5000;

		end loop;
	end;
	$$;

-- esecuzione della stored procedure
call create_sp_employee(10);


-- for
do
$$
declare num int :=0;
begin
	for num in 1..10 loop
		raise notice 'num %', num;
	end loop;
end;
$$

-- esempio di conversione da frenhit a celsius
do
$$
declare
	d int := 0.0;
	celsius float := 0.0;
	minimum int := 32;
	maximum int := 80;
	step    int := 2;
begin
	for f in minimum..maximum by step loop
		celsius = (f-32.0) * (5.0 / 9.0);
		raise notice 'Frenhit = % Celsius = %' , f, celsius:: numeric(10,2);
	end loop;
end;
$$;

-- commit /rollback


create or replace procedure create_sp_employee(number_emp numeric)
	language plpgsql
	as $$
	declare
		startpay numeric := 86000;
		emp_num  int     := 0;
	begin

		while(startpay < 2000000) loop
	
			emp_num := emp_num + 1;


			if emp_num = number_emp then
				exit;
			end if;
	
			if startpay < 0 then
				raise exception 'Stipendio non valido : %', startpay;
			end if;

			raise notice 'emp_id %', emp_num;
			
			insert into sp_employee(annual_salary) values (startpay);

			startpay := startpay - 15000;

		end loop;
	end;
	$$;

call create_sp_employee(10);

--- create new employee

insert into employee (country, email, fullname, gender, address)
	values ('Italy', 'qqqzz@bb.it', 'Marco Uno', 'mascio', 'via bella luna 10 Milano'),
	 ('Italy', 'zzzbb@vv.it', 'Andrea Due', 'mascio', 'Corso Agnelli 12 Torino'),	
	 ('Italy', 'xxxxcc@vv.it', 'Paolo Tre', 'mascio', 'Corso Blue 12 Torino'),	
	 ('Italy', 'ccccvvbb@vv.it', 'Cinzia Quatro', 'femina', 'Via Lagrnage 355 Torino'),	
	 ('Italy', 'xxxxssbb@vv.it', 'Gianni Cinque', 'mascio', 'Corso Francia Milano'),	
	 ('Italy', 'aaaaatt@vv.it', 'Alice Sei', 'femina', 'Via suza 1 Torino'),	
	 ('Italy', 'sssuu@vv.it', 'Giuseppe Sette', 'mascio', 'Corso Monte 33 Roma')	
	 
select * from employee	 

drop table employee_log;
-- definizione tabella employee_log
create table employee_log (
	id int generated by default as IDENTITY,
	id_employee int,
	id_contratto int,
	country varchar(50) not null,
	email varchar(50) not null,
	fullname varchar(50) not null,
	gender varchar(50) not null,
	address varchar(100),
	azione varchar(10) not null,
	azione_time timestamp default  current_timestamp,
	primary key (id)
)


-- funzione di log 
create or replace function log_employee()
returns trigger
as $$
declare
	azione varchar(10);
begin 
	azione := TG_ARGV[0];   -- recupera il paramtetro passato dal trigger
	
	if azione ='delete' then
		if old.id_contratto is not null then
			raise notice 'cancello contratto numero %', old.id_contratto;
			delete from contratto where id_contratto = old.id_contratto;
		end if;
		insert into employee_log(id_employee,id_contratto,country,email,fullname,gender,address,azione)
		  values
	  	(old.id,old.id_contratto,old.country,old.email,old.fullname,old.gender,old.address,azione);
	else
		insert into employee_log(id_employee,id_contratto,country,email,fullname,gender,address,azione)
	  		values
	  	(new.id,new.id_contratto,new.country,new.email,new.fullname,new.gender,new.address,azione);
	end if;

	return new;  	   
end;
$$ language plpgsql;

delete from employee where id = 8;

-- definizione del trigger
-- egenti disponibile :
-- BEFORE INSERT	Prima dell’inserimento
-- AFTER INSERT	Dopo l’inserimento
-- BEFORE UPDATE	Prima di un aggiornamento
-- AFTER UPDATE	Dopo un aggiornamento
-- BEFORE DELETE	Prima della cancellazione
-- AFTER DELETE	Dopo la cancellazione


create or replace trigger trg_log_employee_insert
after insert on employee
for each row
execute function log_employee('insert');

create or replace trigger trg_log_employee_update
after UPDATE on employee
for each row
execute function log_employee('update');

create or replace trigger trg_log_employee_delete
after DELETE on employee
for each row
execute function log_employee('delete');


-- control per validare un campo
create or replace function validate_salay()
returns trigger as $$
begin
	if new.stipendio < 1000 then
		raise exception 'Salary too low';
	end if;	
	return new;
end;
$$ language plpgsql;


update contratto set stipendio = 1250 where id_contratto = 3;

create or replace trigger trg_validate_ertsalary
after insert or update on contratto
for each row
execute function validate_salay();


insert into contratto (stipendio, data_assunzione, id_ruolo, id_categoria)
	values (1900, '2025-06-11', 6, 2);

update employee set id_contratto = 10 where id = 24


select * from employee_log where id=20;



create table contratto_log (
	id int generated by default as IDENTITY,
	id_contratto int not null,
	id_categoria int,
	id_ruolo int,
	stipendio numeric(10) not null,
	data_assunzione date not null,
	data_dimissione date,
	azione varchar(10) not null,
	azione_time timestamp default  current_timestamp,

	primary key (id)
);

-- funzione di log contratto 
create or replace function log_contratto()
returns trigger
as $$
declare
	azione varchar(10);
begin 
	azione := TG_ARGV[0];   -- recupera il paramtetro passato dal trigger
	
	if azione ='delete' then
		insert into contratto_log(id_contratto,id_categoria,id_ruolo,stipendio,data_assunzione,data_dimissione,azione)
		  values
	  	(old.id_contratto,old.id_categoria,old.id_ruolo,old.stipendio,old.data_assunzione,old.data_dimissione,azione);
	else
		insert into contratto_log(id_contratto,id_categoria,id_ruolo,stipendio,data_assunzione,data_dimissione,azione)
		  values
	  	(new.id_contratto,new.id_categoria,new.id_ruolo,new.stipendio,new.data_assunzione,new.data_dimissione,azione);
	end if;

	return new;  	   
end;
$$ language plpgsql;

create or replace trigger trg_log_contratto_delete
after DELETE on contratto
for each row
execute function log_contratto('delete');

-- store procedure di restore
-- questa procedura restore il contratto e employee
-- gestione employee e contratto

CREATE OR REPLACE PROCEDURE restore_employee(p_id_log INTEGER)
LANGUAGE plpgsql
AS $$
DECLARE
    riga employee_log%ROWTYPE;
	cont contratto_log%ROWTYPE;
BEGIN
    SELECT * INTO riga FROM employee_log WHERE id = p_id_log;
	
	if not found then
		RAISE EXCEPTION 'Nothing to restore for %', p_id_log;
    END IF;

    IF riga.azione <> 'delete' THEN
        RAISE EXCEPTION 'Employee % non in modalità DELETE', riga.id_employee;
    END IF;

	if riga.id_contratto is not null then
		raise notice 'Restore contratto %', riga.id_contratto;
 
		select * into cont from contratto_log 
				where id_contratto = riga.id_contratto and azione = 'delete';

		INSERT INTO contratto
			(data_assunzione, data_dimissione, id_categoria, id_contratto, id_ruolo, stipendio)
			VALUES(cont.data_assunzione,
				cont.data_dimissione,
			 	cont.id_categoria,
			 	cont.id_contratto,
			 	cont.id_ruolo,
			 	cont.stipendio); 

		 update contratto_log 
			set azione = 'RESTORED'
			where id = cont.id;
	end if;

	INSERT INTO employee
		(id, id_contratto, country, email, fullname, gender, address)
		VALUES(riga.id_employee,
			riga.id_contratto, 
			riga.country, 
			riga.email, 
			riga.fullname, 
			riga.gender, 
			riga.address);

  update employee_log 
			set azione = 'RESTORED'
			where id = p_id_Log;
END;
$$;





delete from employee where id=5;

call restore_employee(5);

